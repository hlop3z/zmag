{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>     (Z)eroMQ \u2014     (M)anages \u2014     (A) \u2014     (G)raphQL </p> python -m pip install \"zmag[server]\"Successfully installed zmag! <p>ZMAG is a tool designed for building network APIs rather than traditional web applications, leveraging the unique combination of GraphQL and ZeroMQ. By integrating GraphQL's flexible and efficient querying capabilities with ZeroMQ's high-performance messaging patterns, ZMAG enables developers to create robust and scalable network APIs. This approach allows for real-time communication, seamless data transfer, and efficient management of complex, distributed systems, making ZMAG an ideal choice for developers looking to build sophisticated network services that go beyond the capabilities of standard web applications.</p> <p>ZMAG is designed to provide a more Pythonic syntax, moving away from the typical GraphQL and ZeroMQ styles and focusing instead on native Python conventions for greater readability and intuitiveness.</p> <p>Capabilities of ZMAG</p> <ol> <li>Build GraphQL Queries and Mutations for flexible data interactions.</li> <li>Develop Request and Response APIs for efficient communication.</li> <li>Implement Pub/Sub and Push/Pull patterns for robust messaging and data distribution.</li> <li>Leverage Commands to automate processes and streamline operations.</li> </ol>"},{"location":"#built-with","title":"Built With","text":"Module Purpose pyzmq Core Universal Messaging Library for the API. orjson Fast Python JSON library. strawberry GraphQL Library click Manage the server, development processes, and custom Commands. spoc Framework tool for building this framework."},{"location":"#debug-server-built-with","title":"Debug Server Built With","text":"Module Purpose starlette Runs the server in Debug mode. uvicorn ASGI web server. watchdog Restarts the debug server on changes."},{"location":"#installation","title":"Installation","text":"<p>To install ZMAG in different environments, use the following commands:</p>"},{"location":"#development-environment","title":"Development Environment","text":"<pre><code>python -m pip install \"zmag[debug,server]\"\n</code></pre>"},{"location":"#server-environment","title":"Server Environment","text":"<pre><code>python -m pip install \"zmag[server]\"\n</code></pre>"},{"location":"#client-environment","title":"Client Environment","text":"<pre><code>python -m pip install \"zmag\"\n</code></pre> <p>Warning</p> <p>ZMAG is currently in its early stages of development, so there may be some changes in the future. However, we aim to keep the public API stable.</p>"},{"location":"#project-flowchart","title":"Project Flowchart","text":"(API) Application Programming Interface (CLI) Command-Line Interface 1. Load all <code>Settings</code>. 1. Load all <code>Settings</code>. 2. Load <code>Environment Variables</code>. 2. Load <code>Environment Variables</code>. 3. Load all <code>Apps</code> (Packages). 3. Load all <code>Apps</code> (Packages). 4. Start the <code>ZeroMQ</code> API 4. Start the <code>CLI</code> Manager. <pre><code>flowchart LR;\n    subgraph ZMAG &amp; Installed Apps\n    A --&gt; B;\n\n    B &lt;--&gt; D;\n    B &lt;--&gt; E;\n    end\n\n    D &lt;--&gt; F;\n    E &lt;--&gt; G;\n\n    subgraph Your Code\n    F &lt;--&gt; | GraphQL | H\n    G &lt;--&gt; | GraphQL | H\n    end\n\n    A{Click};\n    B[Settings &amp; Apps];\n    D{The API};\n    E{The CLI};\n    F((Operations))\n    G((Commands))\n    H{Project};</code></pre>"},{"location":"#explanation","title":"Explanation","text":"<p>The flowchart illustrates how the project initializes and operates both the API and CLI interfaces:</p> <ol> <li>Initialization: The process begins with Click, which is used to launch both the API (services) and CLI (commands).</li> <li> <p>Configuration Loading: For both the API and CLI interfaces, all <code>Settings</code>, <code>Environment Variables</code>, and <code>Apps (Modules)</code> are loaded. This ensures the environment is properly configured and all necessary modules are available.</p> </li> <li> <p>Starting Interfaces:</p> <p>Interfaces</p> <ul> <li>API \u2014 the ZeroMQ Backend is started to manage backend processes and facilitate operations.</li> <li>CLI \u2014 the CLI Manager is initiated using Click, which handles command-line inputs and operations.</li> </ul> </li> <li> <p>Integration with GraphQL: Both the API and CLI interfaces can connect to the GraphQL, allowing you to perform GraphQL operations through either the API or the CLI.</p> </li> <li> <p>Custom Extensions: You have the flexibility to create custom CLI commands or API methods, which can leverage the underlying GraphQL capabilities.</p> </li> </ol> <p>Tip</p> <p>The setup provides a versatile and unified framework, enabling you to manage backend processes and handle command-line operations effectively, with seamless integration of GraphQL functionalities across both interfaces.</p>"},{"location":"#architectural-patterns","title":"Architectural Patterns","text":"<p>These patterns illustrate the flow of communication in a zmag system:</p>"},{"location":"#backend-frontend","title":"Backend \u2014 Frontend","text":"<p>A direct communication pattern where the Backend communicates with the Frontend.</p> <pre><code>flowchart LR;\n    A[Backend] &lt;--&gt; B[Frontend];</code></pre>"},{"location":"#backend-device-frontend","title":"Backend \u2014 Device \u2014 Frontend","text":"<p>An intermediary device manages the communication between the Backend and Frontend, allowing for scalability.</p> <pre><code>flowchart LR;\n    A[Backend] &lt;--&gt; B((Device)) &lt;--&gt; C[Frontend];\n    F[Backend] &lt;--&gt; B &lt;--&gt; D[Frontend];</code></pre>"},{"location":"#core-layout","title":"Core Layout","text":"<pre><code>root/                           --&gt; &lt;Directory&gt; - Project's Root\n|\n|-- apps/                       --&gt; &lt;Directory&gt; - Project's Apps\n|\n|-- config/                     --&gt; &lt;Directory&gt; - Configurations\n|    |-- .env                   --&gt; &lt;Directory&gt; - Environment Settings\n|    |-- ...\n|    |-- settings.py            --&gt; &lt;File&gt; - Pythonic API Settings\n|    `-- spoc.toml              --&gt; &lt;File&gt; - TOML API Settings\n|\n`-- etc...\n</code></pre>"},{"location":"#key-commands","title":"Key Commands","text":"<p>ZMAG comes with several key commands:</p> Command Purpose <code>zmag-init</code> Create a new ZMAG project. <code>./main.py runserver</code> Run the Server. <code>./main.py start-app</code> Create a ZMAG App inside your <code>apps</code> directory. <code>./main.py --help</code> Display more information about available commands. <p>Important: <code>zmag-init</code> Command</p> <p>Use the <code>zmag-init</code> command only once and make sure you are in a new folder. This command will write files and folders to the current directory.</p>"},{"location":"limitations/","title":"ZMAG Limitations","text":"<p>ZMAG is not intended to function as a full-fledged GraphQL endpoint, particularly in the context of HTTP-based GraphQL features such as subscriptions and federations. Instead, ZMAG is designed to generate self-documenting Python code that offers significant flexibility in the types of output you can request from your operations.</p> <p>The core functionality of ZMAG revolves around ZeroMQ, with GraphQL serving primarily as a convenient means to interact with ZeroMQ. The primary design philosophy behind ZMAG is to be as Pythonic as possible, focusing on creating classes and functions that can be used remotely. The use of GraphQL is supplementary, facilitating the integration with ZeroMQ rather than serving as the main feature.</p> <p>In summary, ZMAG leverages GraphQL for its convenience but is fundamentally centered around ZeroMQ and Pythonic design principles.</p>"},{"location":"motivation/","title":"Motivation \u2014 The Reason Behind","text":"<p>The motivation behind creating this project stems from a gap I noticed in existing solutions: I could not find any projects that combine ZeroMQ and GraphQL. I believe this combination offers a unique and powerful approach to building network applications, particularly for internal use within larger systems.</p> <p>Unlike frameworks like Django, Flask, FastAPI, and others, which are typically designed for building APIs for end-users, ZMAG is tailored for internal projects and microservices. The idea is to create reusable components \u2014 such as an authentication system \u2014 that multiple projects can leverage. For example, you could develop a centralized authentication system with ZMAG and then integrate it with multiple FastAPI or Flask applications. This modular approach allows these components to communicate efficiently, whether they are on the same server, within a local network, or even across the internet.</p> <pre><code>flowchart TB;\n    A --&gt; B;\n    A --&gt; C;\n    A --&gt; D;\n    A --&gt; E;\n    A((Authentication));\n    B{FastAPI};\n    C{Flask};\n    D{Sanic};\n    E{CherryPy};</code></pre> <p>By leveraging ZeroMQ for efficient, low-latency messaging and GraphQL for flexible, self-documenting APIs, ZMAG enables developers to build sophisticated network applications that are both performant and maintainable. The goal is to provide a framework that simplifies the creation of internal services and allows seamless integration across various parts of a project or multiple projects.</p> <p>Additionally, I aimed to make the codebase as Pythonic as possible, minimizing the need to use GraphQL specific syntax. The intent is to create a natural development experience that feels like writing regular Python classes and functions while still benefiting from GraphQL\u2019s automatic documentation and powerful querying capabilities. This approach ensures that developers can focus on building Python applications without needing to extensively learn the intricacies of GraphQL syntax.</p>"},{"location":"use-cases/","title":"Example Use Cases","text":"<ul> <li>Centralized Authentication: Allows multiple applications to share a single authentication system, eliminating the need for individual authentication systems for each application and ensuring consistent security practices.</li> <li>Enterprise Resource Planning (ERP): Ideal for organizations that need secure and efficient communication within their internal network for managing various business processes.</li> <li>Local Database Applications: Suitable for environments where high performance and data security are paramount, enabling quick access and secure handling of sensitive information.</li> </ul>"},{"location":"use-cases/#network-applications","title":"Network Applications","text":"<p>Network applications are software programs that run on multiple computers and devices connected over a network (such as a local area network (LAN), a wide area network (WAN), or the internet). These applications are designed to interact with a network to provide specific functionalities, such as messaging, database access, or remote management.</p>"},{"location":"use-cases/#key-characteristics","title":"Key Characteristics","text":"<ol> <li>Direct Communication: Network applications often use protocols like TCP/IP to communicate directly over a network.</li> <li>Low Latency: Network applications typically have lower latency due to direct communication over the network.</li> <li>Offline Capabilities: Some network applications can work offline and synchronize data when a network connection is reestablished.</li> <li>Complex Configuration: They often require more complex setup and configuration, especially when dealing with network security, firewalls, and access permissions.</li> </ol>"},{"location":"use-cases/#advantages","title":"Advantages","text":"<ul> <li>Performance: Faster communication and data transfer speeds due to direct network connections.</li> <li>Security: Potentially more secure because they can operate within a private network environment.</li> <li>Control and Customization: Greater control over the network environment and application customization based on specific organizational needs.</li> </ul>"},{"location":"use-cases/#network-vs-web-applications-comparison-summary","title":"<code>Network</code> vs <code>Web</code> Applications \u2014 Comparison Summary","text":"Feature Network Applications Web Applications Accessibility Limited to network-connected devices Accessible from any device with a browser Installation Requires installation on each device No installation required Updates May require individual updates or patches Centralized updates on the server Performance Generally faster with lower latency due to direct network connections Dependent on internet speed and server load Security Can be more secure within a private network Security relies on web standards and protocols (HTTPS, etc.) Offline Capabilities Often available Limited (except for PWAs) Development More complex setup and configuration Simpler to develop and deploy using web technologies Scalability May require significant resources for scaling Easily scalable on cloud infrastructure Customization Highly customizable within the network environment Customization often limited to web technologies"},{"location":"api/cli/","title":"Commands <code>API</code> Documentation","text":""},{"location":"api/cli/#command-line-interface-examples","title":"Command-Line Interface \u2014 Examples","text":""},{"location":"api/cli/#zmag.CLI","title":"<code>zmag.CLI</code>","text":"<p>Interface for creating <code>click</code> groups. Instead of using the <code>CLI</code> class directly, utilize it through the <code>cli</code> instance for consistent command-line interface management.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Callable</code>)           \u2013            <p>A callable to be turned into a <code>click.Group</code>.</p> </li> <li> <code>register</code>               (<code>bool | None</code>)           \u2013            <p>Whether to register the <code>group</code> as a component to be loaded.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>group</code>          \u2013            <p>A <code>click</code> group object.</p> </li> </ul> <p>Examples:</p> <pre><code># Simple\n@zmag.cli\ndef cli(): pass\n\n@cli.command()\ndef hello_world():\n    zmag.cli.echo(\"Hello World (Command)\")\n</code></pre> <pre><code># Groups\n@zmag.cli\ndef cli(): pass\n\n@zmag.cli(group=True)\ndef database():  pass\n\n@database.command()\ndef hello_world():\n    zmag.cli.echo(\"Hello World (Command)\")\n\n# Register Group\ncli.add_command(database)\n</code></pre>"},{"location":"api/cli/#zmag.CLI.command","title":"<code>command(obj=None, *, register=True)</code>  <code>classmethod</code>","text":"<p>Decorate a function as a <code>click</code> command.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Callable</code>, default:                   <code>None</code> )           \u2013            <p>A callable to be turned into a <code>click.Command</code>.</p> </li> <li> <code>register</code>               (<code>bool | None</code>, default:                   <code>True</code> )           \u2013            <p>Whether to register the <code>command</code> as a component to be loaded.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>command</code> (              <code>Command | Any</code> )          \u2013            <p>A <code>click</code> command object.</p> </li> </ul>"},{"location":"api/cli/#zmag.CLI.echo","title":"<code>echo(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Wrapper around <code>click.secho</code>.</p>"},{"location":"api/cli/#zmag.CLI.clear","title":"<code>clear()</code>  <code>staticmethod</code>","text":"<p>Wrapper around <code>click.clear</code>.</p>"},{"location":"api/cli/#zmag.CLI.range","title":"<code>range(min=0, max=1, min_open=False, max_open=False, clamp=False)</code>  <code>staticmethod</code>","text":"<p>Wrapper around <code>click.IntRange</code> and <code>click.FloatRange</code>.</p> <p>Returns:</p> <ul> <li> <code>range</code> (              <code>IntRange | FloatRange</code> )          \u2013            <p>range based on the <code>min</code> type.</p> </li> </ul>"},{"location":"api/cli/#zmag.CLI.argument","title":"<code>argument(parameter, type=None, default=None, nargs=None, help=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Wrapper around <code>click.argument</code>.</p>"},{"location":"api/cli/#zmag.CLI.option","title":"<code>option(*parameters, type=None, default=None, nargs=1, is_flag=False, help=None, prompt=None, confirmation_prompt=False, multiple=False, count=False, hide_input=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Wrapper around <code>click.option</code>.</p>"},{"location":"api/cli/#async-commands","title":"Async Commands","text":""},{"location":"api/cli/#zmag.coro","title":"<code>zmag.coro(function)</code>","text":"<p>Transform an asynchronous function into a synchronous function.</p> <p>Parameters:</p> <ul> <li> <code>function</code>               (<code>Coroutine</code>)           \u2013            <p>The regular function to be transformed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>function</code> (              <code>Callable</code> )          \u2013            <p>An async function that runs the original function using <code>asyncio.run()</code>.</p> </li> </ul> CLI <p>Wrap your commands with <code>coro</code> to run async commands with click.</p> <p>Example:</p> <pre><code>@zmag.coro\nasync def async_function(x, y):\n        return x + y\n\nresult = async_function(3, 4)\nprint(result)\n</code></pre>"},{"location":"api/graphql/","title":"GraphQL <code>API</code> Documentation","text":""},{"location":"api/graphql/#graphql-types-examples","title":"GraphQL Types \u2014 Examples","text":""},{"location":"api/graphql/#zmag.Type","title":"<code>zmag.Type(**kwargs)</code>","text":"<p>GraphQL <code>Type</code> base class.</p> <p>Example:</p> <pre><code>class Author(zmag.Type):\n    first_name: str\n    last_name: str\n\n    @property\n    async def full_name(self) -&gt; str:\n        return f\"{self.first_name} {self.last_name}\"\n</code></pre>"},{"location":"api/graphql/#zmag.Model","title":"<code>zmag.Model(_id=None, id=None)</code>  <code>dataclass</code>","text":"<p>GraphQL <code>Model</code> type with a private <code>_id</code> field and a public <code>id</code> field included.</p> <p>Example:</p> <pre><code>class Author(zmag.Type):\n    @property\n    async def merged_ids(self) -&gt; str:\n        return f\"{self._id} and {self.id}\"\n</code></pre>"},{"location":"api/graphql/#zmag.BaseType","title":"<code>zmag.BaseType(**kwargs)</code>","text":"<p>GraphQL Abstract <code>Type</code> for defining common fields and creating a base <code>class</code> for other types.</p> <p>Example:</p> <pre><code># Abstract Class\nclass MyBase(zmag.BaseType):\n    shared_field: str\n\n    class Meta:\n        abstract = True\n\n# New Type - Inheritor\nclass MyType(MyBase): ...\n</code></pre>"},{"location":"api/graphql/#graphql-inputs-examples","title":"GraphQL Inputs \u2014 Examples","text":""},{"location":"api/graphql/#zmag.Input","title":"<code>zmag.Input</code>","text":"<p>Base class for GraphQL <code>Input</code> types, must be used with <code>zmag.input</code> function.</p> <p>Example:</p> <pre><code>input = zmag.input()\n\n@input\nclass Form(zmag.Input):\n    name: str\n    ...\n</code></pre>"},{"location":"api/graphql/#zmag.Input.input","title":"<code>input: Form</code>  <code>instance-attribute</code>","text":"<p>Returns the processed value from <code>zmag.Input</code>.</p> <p>Example:</p> <pre><code>async def mutation(form: Form):\n    print(form.input)\n</code></pre>"},{"location":"api/graphql/#zmag.Form","title":"<code>zmag.Form(data=SimpleNamespace(), errors=list(), is_valid=False, next=None)</code>  <code>dataclass</code>","text":"<p>Represents an <code>Input</code> response.</p> <p>This class extends <code>zmag.Input</code> and provides methods to handle form data, including cleaning and converting it to a dictionary format.</p> <p>Attributes:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>The input data stored in a <code>SimpleNamespace</code>.</p> </li> <li> <code>errors</code>               (<code>list</code>)           \u2013            <p>A list of errors associated with the form.</p> </li> <li> <code>is_valid</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the form data is valid.</p> </li> </ul> <p>Example:</p> <pre><code>class Form(zmag.Input): ...\n\nasync def mutation(form: Form):\n    print(form.input)\n    print(form.input.clean())\n    print(form.input.dict(True))\n</code></pre>"},{"location":"api/graphql/#zmag.Form.dict","title":"<code>dict(clean=False)</code>","text":"<p>Convert the form data to a <code>dict</code>.</p> <p>Parameters:</p> <ul> <li> <code>clean</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, exclude keys with <code>UNSET</code> values from the dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>dict</code> )          \u2013            <p>The input data as a dictionary, optionally cleaned of <code>UNSET</code> values.</p> </li> </ul>"},{"location":"api/graphql/#zmag.Form.clean","title":"<code>clean()</code>","text":"<p>Convert the form data to a <code>SimpleNamespace</code>, excluding <code>UNSET</code> values.</p> <p>Returns:</p> <ul> <li> <code>data</code> (              <code>SimpleNamespace</code> )          \u2013            <p>The input data as a <code>SimpleNamespace</code>, cleaned of <code>UNSET</code> values.</p> </li> </ul>"},{"location":"api/graphql/#zmag.input","title":"<code>zmag.input(prefix=None, suffix=None)</code>","text":"<p>Creates a <code>decorator</code> for <code>Inputs</code>, optionally adding a common prefix or suffix.</p> <p>This function extends <code>zmag.Input</code>.</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The prefix to be added to each field in the class.</p> </li> <li> <code>suffix</code>               (<code>str | list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The suffix to be added to each field in the class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>decorator</code> (              <code>Callable</code> )          \u2013            <p>To wrap GraphQL <code>Input</code> types.</p> </li> </ul> <p>Example:</p> <pre><code>Author = zmag.input(\"Author\")\n\n@Author\nclass Create(zmag.Input): ... # AuthorCreate\n\n@Author\nclass Update(zmag.Input): ... # AuthorUpdate\n</code></pre>"},{"location":"api/graphql/#zmag.value","title":"<code>zmag.value(default=UNSET, required=False, regex=None, rules=None, clean=None, deprecation_reason=None)</code>","text":"<p>Configuration options for the <code>Input</code> value.</p> <p>This function extends <code>zmag.Input</code>.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>Any</code>, default:                   <code>UNSET</code> )           \u2013            <p>The default value for the field.</p> </li> <li> <code>required</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indicates whether the field is mandatory.</p> </li> <li> <code>regex</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary defining regular expressions for field validation.</p> </li> <li> <code>rules</code>               (<code>list | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of validation rules to apply to the field.</p> </li> <li> <code>clean</code>               (<code>ValueCleaner | None</code>, default:                   <code>None</code> )           \u2013            <p>A callable used to configure preprocess of the value.</p> </li> <li> <code>deprecation_reason</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A message explaining why the field is deprecated.</p> </li> </ul> <p>Example:</p> <p>GraphQL: <code>(form: {x: \"required_field\", email: \"demo@helloworld.com\"})</code></p> <pre><code>class MyForm(zmag.Input):\n    # A required field with no default value,\n    # ensuring the field must be filled.\n    x: str = zmag.value(required=True)\n\n    # A field with a default value,\n    # optionally using a function for initialization.\n    y: str = zmag.value(default=\"Some Value\")\n    y: str = zmag.value(default=lambda: \"Some Value\")\n\n    # A deprecated field \"not for use\",\n    # in the near future or at all.\n    z: str = zmag.value(deprecation_reason=\"Value is deprecated\")\n\n    # A complex field setup demonstrating validation,\n    # cleaning, and transformation of input data.\n    email: str = zmag.value(\n        regex={\n            # A field with regex validation.\n            r\"[\\w\\.-]+@[\\w\\.-]+\": \"Invalid email address\"\n        },\n        rules=[\n            # Additional custom validation rules.\n            (lambda v: v.startswith(\"demo\") or \"Invalid input\")\n        ],\n        clean=zmag.clean(\n            regex=[\n                # Replace using regex in the cleaning phase.\n                (r\"^hello\", \"hola\"),\n                (r\"com\", \"api\"),\n            ],\n            rules=[\n                # Apply custom rules after regex replacements.\n                (lambda v: v.upper())\n            ],\n        ),\n    )\n</code></pre>"},{"location":"api/graphql/#zmag.clean","title":"<code>zmag.clean(regex=None, rules=None)</code>","text":"<p>Creates a <code>ValueCleaner</code> configuration with regex filters and custom rules.</p> <p>This function extends <code>zmag.value</code>.</p> <p>Parameters:</p> <ul> <li> <code>regex</code>               (<code>list | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of regex patterns for filtering input value.</p> </li> <li> <code>rules</code>               (<code>list | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of rules (functions or lambdas) to apply to input value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>config</code> (              <code>ValueCleaner</code> )          \u2013            <p>A dictionary containing <code>regex</code> and <code>rules</code> for input value cleaning.</p> </li> </ul> <p>Example:</p> <pre><code>zmag.clean(\n    regex=[\n        # Replace text using regex in the cleaning phase.\n        (r\"^hello\", \"hola\"),\n        (r\"com\", \"api\"),\n    ],\n    rules=[\n        # Apply further custom rules after regex replacements.\n        (lambda v: v.upper())\n    ],\n)\n</code></pre>"},{"location":"api/graphql/#graphql-operations-examples","title":"GraphQL Operations \u2014 Examples","text":""},{"location":"api/graphql/#zmag.gql","title":"<code>zmag.gql(cls=None)</code>","text":"<p>This class decorator transforms a Python class into GraphQL operations.</p> <p>When applied to a class, <code>@zmag.gql</code> interprets inner classes named <code>Query</code> and <code>Mutation</code> as containers for GraphQL query and mutation methods, respectively. These methods can then be invoked as part of a GraphQL API.</p> <p>Attributes:</p> <ul> <li> <code>Meta</code>               (<code>class</code>)           \u2013            <p>Defines metadata for the GraphQL class, such as the associated <code>app</code> and <code>model</code>.</p> </li> <li> <code>Query</code>               (<code>class</code>)           \u2013            <p>Contains methods that represent GraphQL queries. Each method should be an <code>async</code> function and can return various data types.</p> </li> <li> <code>Mutation</code>               (<code>class</code>)           \u2013            <p>Contains methods that represent GraphQL mutations. Each method should be an <code>async</code> function and can accept input data for modifying server-side state.</p> </li> </ul> Meta class Attributes: <ul> <li> <p><code>app</code> (<code>str | bool | None</code>): Specifies a prefix for the GraphQL field names. If set to <code>None</code>, the prefix is omitted, and the field names are based directly on the method names.</p> </li> <li> <p><code>model</code> (<code>str | type | None</code>): When specified, prefixes the GraphQL field names with the model name. This helps in creating more descriptive and structured GraphQL schemas.</p> </li> </ul> Tip <p>This decorator allows you to seamlessly integrate Python classes with a GraphQL API.</p> <p>Example:</p> <pre><code>@zmag.gql\nclass Graphql:\n\n    class Meta:\n        app = True\n        model = \"Book\"\n\n    class Query: ...\n\n    class Mutation: ...\n</code></pre>"},{"location":"api/graphql/#graphql-output-examples","title":"GraphQL Output \u2014 Examples","text":""},{"location":"api/graphql/#zmag.Edge","title":"<code>zmag.Edge: TypeAlias = Connection[T, JSON]</code>  <code>module-attribute</code>","text":""},{"location":"api/graphql/#zmag.edge","title":"<code>zmag.edge(edges=None, count=0, pages=0, has_next=False, has_previous=False, computed=None)</code>","text":"<p>Extends <code>Edges</code> used to return a <code>Page</code> response.</p> <p>Example:</p> <pre><code>async def search(self) -&gt; zmag.Edge[types.Book]:\n    return zmag.edge(\n        count=1,\n        pages=1,\n        edges=[\n            types.Book(\n                id=1,\n                title=\"The Great Gatsby\",\n            ),\n        ],\n        computed={\n            \"someComputedValue\": 100,\n        },\n    )\n</code></pre>"},{"location":"api/graphql/#zmag.Mutation","title":"<code>zmag.Mutation(item=None, many=field(default_factory=list), error=None, deleted=0)</code>  <code>dataclass</code>","text":"<p>Represents a GraphQL <code>Mutation</code> response, handling the outcome of mutation operations.</p> <p>Example:</p> <pre><code>async def create(self) -&gt; zmag.Mutation[types.Book]:\n    data = form.input.dict(True)\n    return zmag.Mutation(\n        item=types.Book(title=data.get(\"title\")),\n    )\n</code></pre>"},{"location":"api/graphql/#zmag.Error","title":"<code>zmag.Error(field=None, type=None, text=None)</code>  <code>dataclass</code>","text":"<p>A structured format for GraphQL error messages to be used in <code>Errors</code> responses.</p>"},{"location":"api/graphql/#zmag.Errors","title":"<code>zmag.Errors(messages=field(default_factory=list), meta=field(default_factory=dict), error=True)</code>  <code>dataclass</code>","text":"<p>A comprehensive response object for handling multiple GraphQL <code>Errors</code>.</p> <p>Example:</p> <pre><code>Errors(\n    meta={\"note\": \"reset form.\"}\n    messages=[\n        Error(field=\"username\", type=\"invalid\", text=\"username must be lowercase.\"),\n    ],\n)\n</code></pre>"},{"location":"api/graphql/#zmag.input_error","title":"<code>zmag.input_error(messages, meta=None)</code>","text":"<p>A simplified error handler for mutation <code>Errors</code>.</p> <p>Returns:</p> <ul> <li> <code>response</code> (              <code>Mutation</code> )          \u2013            <p>GraphQL Mutation</p> </li> </ul> <pre><code>async def create(self, form: inputs.Create) -&gt; zmag.Mutation[types.Book]:\n    # Not Valid\n    if not form.input.is_valid:\n        return zmag.input_error(form.input.errors)\n\n    # Is Valid\n    ...\n</code></pre>"},{"location":"api/graphql/#graphql-input-examples","title":"GraphQL Input \u2014 Examples","text":""},{"location":"api/graphql/#zmag.Pagination","title":"<code>zmag.Pagination</code>","text":"<p>An input for managing pagination, for efficient <code>navigation</code> and retrieval of database records.</p> <p>Example:</p> <pre><code>class Query:\n    async def search(self, pagination: zmag.Pagination):\n        ...\n</code></pre>"},{"location":"api/graphql/#zmag.Selector","title":"<code>zmag.Selector</code>","text":"<p>A utility for <code>selecting</code> database record(s).</p> <p>Example:</p> <pre><code>class Query:\n    async def detail(self, record: zmag.Selector):\n        ...\n</code></pre>"},{"location":"api/zeromq/","title":"ZeroMQ <code>API</code> Documentation","text":""},{"location":"api/zeromq/#zeromq-data","title":"ZeroMQ Data","text":""},{"location":"api/zeromq/#zmag.Data","title":"<code>zmag.Data(meta=dict(), head=dict(), body=dict())</code>  <code>dataclass</code>","text":"<p>A utility class for handling JSON serialization and compression for ZMQ communication.</p>"},{"location":"api/zeromq/#zmag.Data.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Set Custom Serializer</p>"},{"location":"api/zeromq/#zmag.Data.recv","title":"<code>recv(message)</code>  <code>classmethod</code>","text":"<p>Receives and deserializes a ZeroMQ message.</p>"},{"location":"api/zeromq/#zmag.Data.send","title":"<code>send(channel='', command='request', node='')</code>","text":"<p>Serializes and compresses data to send as a ZeroMQ message.</p>"},{"location":"api/zeromq/#zeromq-backend-examples","title":"ZeroMQ Backend \u2014 Examples","text":""},{"location":"api/zeromq/#zmag.Device","title":"<code>zmag.Device(mode='queue', backend=tcp_string(5556), frontend=tcp_string(5555), publickey=None, secretkey=None)</code>","text":"<p>ZeroMQ <code>Proxy</code> Device</p>"},{"location":"api/zeromq/#zmag.Device.start","title":"<code>start()</code>","text":"<p>Run Device</p>"},{"location":"api/zeromq/#zmag.Backend","title":"<code>zmag.Backend(mode='queue', backend=tcp_string(5556), frontend=tcp_string(5555), name=None, attach=False, publickey=None, secretkey=None, serverkey=None)</code>","text":"<p>ZeroMQ <code>Backend</code> Server</p>"},{"location":"api/zeromq/#zmag.Backend.recv","title":"<code>recv()</code>  <code>async</code>","text":"<p>Receive <code>Request</code> (JSON).</p>"},{"location":"api/zeromq/#zmag.Backend.send","title":"<code>send(__head__=None, **kwargs)</code>  <code>async</code>","text":"<p>Send <code>Response</code> (JSON).</p> <p>Parameters:</p> <ul> <li> <code>__head__</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Request headers.</p> </li> <li> <code>body</code>               (<code>**kwargs</code>)           \u2013            <p>Request body.</p> </li> </ul> <p>Example:</p> <pre><code>backend = zmag.Backend(...)\n\nbackend.send({\"token\":\"secret\"}, message = \"hello world\")\n</code></pre>"},{"location":"api/zeromq/#zmag.Backend.publish","title":"<code>publish(channel, data)</code>  <code>async</code>","text":"<p>Send <code>Pub</code> (JSON).</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Data</code>)           \u2013            <p>description</p> </li> </ul> <p>Example:</p> <pre><code>backend = zmag.Backend(...)\n\ndata = zmag.Data(body={\"message\": \"hello world\"})\n\nbackend.publish(\"channel\", data)\n</code></pre>"},{"location":"api/zeromq/#zmag.Backend.push","title":"<code>push(data)</code>  <code>async</code>","text":"<p>Send <code>Push</code> Work (JSON).</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Data</code>)           \u2013            <p>description</p> </li> </ul> <p>Example:</p> <pre><code>backend = zmag.Backend(...)\n\ndata = zmag.Data(body={\"message\": \"hello world\"})\n\nbackend.push(data)\n</code></pre>"},{"location":"api/zeromq/#zmag.pub","title":"<code>zmag.pub(obj=None, *, channel=None, seconds=0, minutes=0, hours=0, days=0)</code>","text":"<p>This decorator transforms an <code>async</code> function into a ZeroMQ <code>publisher</code>, enabling it to broadcast data to the frontend.</p> <p>The function publishes either <code>zmag.Data</code> or <code>None</code> based on the availability of updates.</p> <p>Returns:</p> <ul> <li> <code>Data | None</code>           \u2013            <p>Return <code>zmag.Data</code> if updates are available, <code>None</code> If no updates are available.</p> </li> </ul> <p>Example:</p> <pre><code>@zmag.pub # or zmag.pub(seconds=5)\nasync def topic(): # `topic` is the channel\n    response = zmag.Data()\n    response.body = {\"message\": \"hello world\"}\n    return response\n\n@zmag.pub(seconds=5)\nasync def generic(): # Custom `channel`\n    response = zmag.Data()\n    response.meta[\"channel\"] = \"custom\"\n    ...\n\n@zmag.pub\nasync def graphql(context): # GraphQL\n    gql_query = \"query { books { id title } }\"\n    results = await context.schema.execute(gql_query)\n    ...\n</code></pre>"},{"location":"api/zeromq/#zmag.push","title":"<code>zmag.push(obj=None, *, seconds=0, minutes=0, hours=0, days=0)</code>","text":"<p>This decorator transforms an <code>async</code> function into a ZeroMQ pusher, allowing it to send data for the frontend to consume.</p> <p>The function pushes either <code>zmag.Data</code> or <code>None</code>, based on whether there is new data available.</p> <p>Returns:</p> <ul> <li> <code>Data | None</code>           \u2013            <p>Return <code>zmag.Data</code> If there is data to be sent, <code>None</code> If there is no data to send.</p> </li> </ul> <p>Example:</p> <pre><code>@zmag.push # or zmag.push(seconds=5)\nasync def push_method(): #\n    response = zmag.Data()\n    response.body = {\"message\": \"hello world\"}\n    return response\n\n@zmag.push\nasync def push_graphql(context): # GraphQL\n    gql_query = \"query { books { id title } }\"\n    results = await context.schema.execute(gql_query)\n    ...\n</code></pre>"},{"location":"api/zeromq/#zeromq-frontend-examples","title":"ZeroMQ Frontend \u2014 Examples","text":""},{"location":"api/zeromq/#zmag.Frontend","title":"<code>zmag.Frontend(mode='queue', host=tcp_string(5555), timeout=5000, is_sync=False, ssh=None, publickey=None, secretkey=None, serverkey=None)</code>","text":"<p>ZeroMQ <code>Frontend</code> Client</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>, default:                   <code>tcp_string(5555)</code> )           \u2013            <p>description.</p> </li> <li> <code>timeout</code>               (<code>int</code>, default:                   <code>5000</code> )           \u2013            <p>description.</p> </li> <li> <code>is_sync</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>description.</p> </li> <li> <code>ssh</code>               (<code>ConfigSSH | None</code>, default:                   <code>None</code> )           \u2013            <p>description.</p> </li> <li> <code>publickey</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>description.</p> </li> <li> <code>secretkey</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>description.</p> </li> <li> <code>serverkey</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>description.</p> </li> </ul>"},{"location":"api/zeromq/#zmag.Frontend.request","title":"<code>request(query=None, operation=None, variables=None, context=None)</code>","text":"<p>Sends a <code>Request</code> to the server.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>description.</p> </li> <li> <code>operation</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>description.</p> </li> <li> <code>variables</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>description.</p> </li> <li> <code>context</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>description.</p> </li> </ul> <p>Example:</p> <pre><code>client = zmag.Frontend(...)\n\nresponse = await client.request(...)\nprint(response)\n</code></pre>"},{"location":"api/zeromq/#zmag.Frontend.subscribe","title":"<code>subscribe(channel='')</code>","text":"<p>Subscribes to a ZeroMQ channel to receive messages and updates in real-time.</p> <p>Parameters:</p> <ul> <li> <code>channel</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>description.</p> </li> </ul> <p>Example:</p> <pre><code>client = zmag.Frontend(...)\n\nwhile True:\n    message = await client.subscribe(\"\") # or \"some_channel\"\n    print(\"Received:\", message)\n</code></pre>"},{"location":"api/zeromq/#zmag.Frontend.pull","title":"<code>pull()</code>","text":"<p>Consumes data from a ZeroMQ producer, processing incoming workloads.</p> <p>Example:</p> <pre><code>client = zmag.Frontend(...)\n\nwhile True:\n    work = await client.pull()\n    print(\"Received:\", work)\n</code></pre>"},{"location":"api/zeromq/#zmag.ConfigSSH","title":"<code>zmag.ConfigSSH(host, keyfile=None, password=None, paramiko=None, timeout=60)</code>  <code>dataclass</code>","text":"<p>ZeroMQ SSH Configuration</p> <ul> <li>https://pyzmq.readthedocs.io/en/latest/howto/ssh.html</li> </ul>"},{"location":"client/authentication/","title":"Authentication","text":"<p>ZMAG provides multiple ways to authenticate your client, either via Keys or through SSH configuration.</p>"},{"location":"client/authentication/#authentication-via-keys","title":"Authentication via Keys","text":"<p>To authenticate using keys, pass the <code>publickey</code>, <code>secretkey</code>, and <code>serverkey</code> directly to the <code>Frontend</code> instance.</p> <pre><code>from zmag import Frontend\n\nclient = Frontend(\n    publickey=\"public-key-x7i+CS&lt;BVZMJyXEX)H8?31k5o)?mQ\",  # Client's public key\n    secretkey=\"secret-key-x(&lt;$ES*$pZ3UmIPEIy+lt1qNY!!Kn\",  # Client's secret key\n    serverkey=\"server-key-QAvkkf}^Y5OVu=R?S&lt;V9Xi-Y!Zm4q\",  # Server's public key\n)\n</code></pre>"},{"location":"client/authentication/#key-details","title":"Key Details","text":"<ul> <li>Public Key: Identifies your client.</li> <li>Secret Key: Authenticates your client to the server.</li> <li>Server Key: The public key of the server you are connecting to.</li> </ul>"},{"location":"client/authentication/#generate-key-pair","title":"Generate Key Pair","text":"<pre><code>import zmag\n\npublickey, secretkey = zmag.keypair()\n</code></pre>"},{"location":"client/authentication/#authentication-via-ssh","title":"Authentication via SSH","text":"<p>Alternatively, you can authenticate via SSH by passing an SSH configuration using <code>ConfigSSH</code>.</p> <pre><code>from zmag import Frontend, ConfigSSH\n\nclient = Frontend(\n    ssh=ConfigSSH(\n        host=\"user@server:port\",  # Specify the SSH host and port\n        keyfile=\"key/file/path\",  # Path to the SSH private key file\n    )\n)\n</code></pre>"},{"location":"client/authentication/#ssh-configuration","title":"SSH Configuration","text":"<ul> <li>Host: Specifies the user, server, and port in the format <code>user@server:port</code>.</li> <li>Keyfile: The path to your SSH private key file used for authentication.</li> </ul> <p>By choosing between key-based or SSH-based authentication, you can securely configure your client based on your application\u2019s needs.</p>"},{"location":"client/intro/","title":"Client Introduction","text":"<p>To get started with the ZMAG client, first install the package:</p> <pre><code>python -m pip install \"zmag\"\n</code></pre>"},{"location":"client/intro/#client-setup","title":"Client Setup","text":"<p>To create a client instance using the <code>Frontend</code> class, you need to specify the server address and mode.</p> <pre><code>from zmag import Frontend\n\nclient = Frontend(\n    host=\"tcp://127.0.0.1:5555\",  # Define the host address\n    mode=\"queue\",  # Specify the messaging mode\n    is_sync=True,  # Whether the client operates in synchronous mode\n)\n</code></pre>"},{"location":"client/intro/#synchronous-mode","title":"Synchronous Mode","text":"<p>By setting <code>is_sync=True</code>, the client operates in synchronous mode, allowing the methods to run synchronously. By default, ZMAG operates asynchronously.</p>"},{"location":"client/intro/#when-to-use-sync-mode","title":"When to Use Sync Mode","text":"<ul> <li>Django Integration: Sync mode is useful when running the client within Django or any other framework that expects synchronous execution.</li> <li>Testing: Useful for simplifying test cases that don't require asynchronous execution.</li> </ul>"},{"location":"client/intro/#mode-options","title":"Mode Options","text":"<p>The <code>mode</code> parameter defines the communication pattern. The mode you choose must align with the mode in which the server/backend is configured.</p> <ul> <li><code>queue</code>: For request-response communication.</li> <li><code>streamer</code>: For push-pull messaging patterns.</li> <li><code>forwarder</code>: For publish-subscribe messaging patterns.</li> </ul> <p>Ensure the client\u2019s <code>mode</code> matches the server\u2019s to facilitate proper communication.</p> <p>This setup provides flexibility based on the communication pattern you need.</p>"},{"location":"client/requests/","title":"ZMAG Requests","text":"<p>This example demonstrates how to make GraphQL requests using ZMAG\u2019s <code>Frontend</code> class.</p> <pre><code>from zmag import Frontend\n\nclient = Frontend(\n    host=\"tcp://127.0.0.1:5555\",  \n    mode=\"queue\",  \n    is_sync=False,  \n)\n</code></pre>"},{"location":"client/requests/#graphql-request","title":"GraphQL Request","text":"<p>ZMAG allows you to send GraphQL queries or mutations to a remote service. Below is an example of how to perform a GraphQL query using the <code>request</code> method.</p> <pre><code>GQL_QUERY = \"\"\"\nquery MyQuery($title: String) {\n  bookDetail(title: $title) {\n    id\n    title\n  }\n}\n\"\"\"\n\nresponse = await client.request(\n    query=GQL_QUERY,  # The GraphQL query to be executed\n    variables={\n        \"title\": \"Jurassic Park\",  # Pass any required query variables\n    },\n    operation=\"MyQuery\",  # Name of the GraphQL operation\n    context={\n        \"user\": {  # Provide additional context, such as user data\n            \"id\": 1,\n            \"username\": \"admin\",\n            \"is_staff\": True,\n            \"is_active\": True,\n            \"is_superuser\": True,\n            \"is_authenticated\": True,\n        }\n    },\n)\n\n# Output the result of the GraphQL request\nprint(response.body[\"data\"])\n</code></pre>"},{"location":"client/requests/#explanation","title":"Explanation","text":"<ul> <li>GQL_QUERY: The GraphQL query is defined as a string, and it includes a parameter <code>$title</code> to query for a book by title.</li> <li><code>variables</code>: The variables required by the query are passed as a dictionary, in this case, the title <code>\"Jurassic Park\"</code>.</li> <li><code>operation</code>: Specifies the name of the GraphQL operation (<code>\"MyQuery\"</code>).</li> <li><code>context</code>: Allows you to send additional data, such as user information, with the request.</li> <li><code>response.body[\"data\"]</code>: This is where you access the returned data from the GraphQL server.</li> </ul> <p>This example provides a flexible way to integrate GraphQL queries within a ZMAG environment.</p>"},{"location":"client/sub-pull/","title":"<code>Subscribe</code> and <code>Pull</code> in ZMAG","text":"<p>These examples demonstrate how to use the <code>Frontend</code> class in ZMAG for subscribing to channels and pulling work from a server.</p> <pre><code>from zmag import Frontend\n\nclient = Frontend(\n    host=\"tcp://127.0.0.1:5555\",\n    mode=\"queue\",\n    is_sync=False,  \n)\n</code></pre>"},{"location":"client/sub-pull/#subscribe","title":"Subscribe","text":"<p>The <code>subscribe</code> method is used to listen for messages from specific channels.</p>"},{"location":"client/sub-pull/#subscribe-to-all-channels","title":"Subscribe to All Channels","text":"<p>Subscribing with an empty string (<code>\"\"</code>) listens to messages from all channels.</p> <pre><code>while True:\n    message = await client.subscribe(\"\")\n    print(\"Received:\", message)\n</code></pre>"},{"location":"client/sub-pull/#subscribe-to-a-specific-channel","title":"Subscribe to a Specific Channel","text":"<p>To limit the subscription to a particular channel, pass the channel name as an argument.</p> <pre><code>while True:\n    message = await client.subscribe(\"the_channel\")\n    print(\"Received:\", message)\n</code></pre>"},{"location":"client/sub-pull/#pull","title":"Pull","text":"<p>The <code>pull</code> method is used to receive work from a push-pull pattern (also known as task distribution).</p> <pre><code>while True:\n    work = await client.pull()\n    print(\"Received:\", work)\n</code></pre>"},{"location":"server/authentication/","title":"Authentication","text":"<p>To enable authentication, you need to configure two settings:</p> <ol> <li>In <code>config/spoc.toml</code>, set <code>authentication = true</code>.</li> <li>Configure the keys in the <code>config/.env/&lt;environment&gt;.toml</code> file.</li> </ol> <p>You can also set the keys via environment variables. Learn More</p>"},{"location":"server/authentication/#key-generation","title":"Key Generation","text":"python main.py gen-keys[env.zmq]public_key = \"public-key-x7i+CS&lt;BVZMJyXEX)H8?31k5o)?mQ\"secret_key = \"secret-key-x(&lt;$ES*$pZ3UmIPEIy+lt1qNY!!Kn\""},{"location":"server/authentication/#configuration","title":"Configuration","text":"<p>Example Configuration:</p> config/spoc.toml<pre><code>[spoc]\n...\nauthentication = true\n</code></pre>"},{"location":"server/authentication/#authentication-keys","title":"Authentication Keys","text":"<p>Example Configuration:</p> config/.env/production.toml<pre><code>[env] # Environment Settings\n\n[env.zmq] # ZeroMQ Configuration\npublic_key = \"public-key-x7i+CS&lt;BVZMJyXEX)H8?31k5o)?mQ\"\nsecret_key = \"secret-key-x(&lt;$ES*$pZ3UmIPEIy+lt1qNY!!Kn\"\nserver_key = \"server-key-QAvkkf}^Y5OVu=R?S&lt;V9Xi-Y!Zm4q\" # IF Device\n</code></pre> <p>Server Key</p> <p>The <code>server_key</code> is required if you are using devices. In this context, the \"<code>server</code>\" refers to the device. If you are not using devices, the server acts as the primary server, and you do not need to configure the <code>server_key</code>.</p> <pre><code>...\nserver_key = \"server-key-QAvkkf}^Y5OVu=R?S&lt;V9Xi-Y!Zm4q\" # IF Device\n</code></pre>"},{"location":"server/commands/","title":"Commands","text":"<p>To set up commands in your ZMAG application, the code must be located in a file named <code>commands.py</code> or in a folder named <code>commands</code> within the application directory.</p> <p>Note</p> <p><code>zmag.cli</code> is a specialized wrapper for <code>click.group</code>.</p> <p>The primary distinction between <code>click</code> and <code>zmag</code> commands is that <code>zmag</code> adds predefined configurations and can infer certain settings, such as <code>type</code>, <code>required</code>, and <code>default</code>, directly from function parameters. This makes the implementation more Pythonic and compatible with type hints.</p>"},{"location":"server/commands/#cli-tools-reference","title":"CLI Tools \u2014 Reference","text":"<ul> <li><code>zmag.cli</code> \u2014 Interface for creating <code>click.Group</code> commands.</li> <li><code>zmag.cli.argument</code> \u2014 A wrapper around <code>click.argument</code>.</li> <li><code>zmag.cli.option</code> \u2014 A wrapper around <code>click.option</code>.</li> <li><code>zmag.cli.range</code> \u2014 A wrapper around <code>click.IntRange</code> and <code>click.FloatRange</code>.</li> <li><code>zmag.coro</code> \u2014 Transform an <code>asynchronous</code> function into a <code>synchronous</code> function.</li> </ul> <p>Tip</p> <p>Use these tools for creating CLI commands in your application.</p>"},{"location":"server/commands/#examples","title":"Examples","text":""},{"location":"server/commands/#basic-command-example","title":"Basic Command Example","text":"commands.py<pre><code>import zmag\n\n# Initialize CLI group\n@zmag.cli.group\ndef cli():\n    \"\"\"Main CLI group.\"\"\"\n\n# Define commands here\n@cli.command()\ndef hello_world():\n    \"\"\"Demo command that prints a message.\"\"\"\n\n    zmag.cli.echo(\"Hello World (Command)\")\n</code></pre> <p>Terminal Output:</p> python main.py hello-worldHello World (Command)"},{"location":"server/commands/#sub-group-example","title":"Sub-Group Example","text":"commands.py<pre><code>import zmag\n\n# Initialize CLI group\n@zmag.cli\ndef cli():\n    \"\"\"Main CLI group.\"\"\"\n\n# Initialize subgroup\n@zmag.cli(group=True)\ndef database():\n    \"\"\"Database operations group.\"\"\"\n\n# Define commands within subgroup\n@database.command()\ndef migrate():\n    \"\"\"Command to migrate the database.\"\"\"\n\n    zmag.cli.echo(\"Migrate (Database)\")\n\n# Attach subgroup to main CLI\ncli.add_command(database)\n</code></pre> <p>Terminal Output:</p> python main.py database migrateMigrate (Database)"},{"location":"server/commands/#coroutine-command-example","title":"Coroutine Command Example","text":"<pre><code>@cli.command()\n@zmag.coro # (1)\nasync def hello_world():\n    \"\"\"Demo async command.\"\"\"\n</code></pre> <ol> <li>Transform <code>asynchronous</code> function into a <code>synchronous</code> function.</li> </ol>"},{"location":"server/commands/#typing-example-with-arguments-and-options","title":"Typing Example with <code>Arguments</code> and <code>Options</code>","text":"<pre><code>from typing import Literal\nfrom datetime import datetime\nfrom pathlib import Path\n\n@cli.command()\n@zmag.cli.argument(\"message\", help=\"Custom help message.\")\n@zmag.cli.argument(\"count\", help=\"Number of times to repeat the message.\")\n@zmag.cli.option(\"--folder\", help=\"Path to a folder.\")\n@zmag.cli.option(\"--when\", help=\"Timestamp for the operation.\")\n@zmag.cli.option(\"--logging\", help=\"Logging level.\")\n@zmag.cli.option(\"--scale\", type=zmag.cli.range(1, 5), help=\"Scale between 1 and 5.\")\n@zmag.cli.option(\"--scope\", type=zmag.cli.range(1.0, 5.0), help=\"Scope between 1.0 and 5.0.\")\ndef hello_world(\n    message: str,  # Required (1)\n    count: int | None,  # Optional (2)\n    folder: Path | None = None,  # Path (3)\n    when: datetime | None = None,  # Datetime (4)\n    logging: Literal[\"level_one\", \"level_two\"] | None = None,  # Choice (5)\n    scale: int | None = None, # with click.IntRange\n    scope: float | None = None, # with click.FloatRange\n):\n    \"\"\"Demo command that demonstrates various options and arguments.\"\"\"\n</code></pre> <ol> <li>Required field <code>(required=True)</code>.</li> <li>Optional field <code>(required=False)</code>.</li> <li>Path type uses <code>click.Path</code>.</li> <li>Datetime type uses <code>click.DateTime</code>.</li> <li>Choice type uses <code>click.Choice</code>.</li> </ol> <p>Tip</p> <ul> <li>For choices use <code>typing.Literal</code>.</li> <li>To mark a field as optional use <code>&lt;type&gt; | None</code>.</li> </ul>"},{"location":"server/devices/","title":"Devices","text":"<p>ZeroMQ devices are specialized components provided by the ZeroMQ messaging library to facilitate complex messaging patterns. They serve as intermediaries that handle specific messaging tasks, such as forwarding messages between different types of sockets, proxying, and load balancing. Devices simplify the creation of advanced messaging workflows by managing the intricacies of message routing and handling.</p>"},{"location":"server/devices/#purpose","title":"Purpose","text":"<ol> <li>Message Forwarding: Efficiently routes messages between different sockets.</li> <li>Proxying: Acts as an intermediary to manage communication between various endpoints.</li> <li>Load Balancing: Distributes messages evenly across multiple workers.</li> </ol>"},{"location":"server/devices/#types-of-devices","title":"Types of Devices","text":"<ul> <li><code>Queue</code>: Implements <code>Request/Response</code> patterns, handling message queues.</li> <li><code>Forwarder</code>: Implements <code>Publish/Subscribe</code> patterns, forwarding messages between publishers and subscribers.</li> <li><code>Streamer</code>: Implements <code>Push/Pull</code> patterns, managing the flow of messages between producers and consumers.</li> </ul>"},{"location":"server/devices/#advantages","title":"Advantages","text":"<ul> <li>Abstraction: Devices abstract complex message routing and handling, simplifying application development.</li> <li>Scalability: Supports scalable and flexible messaging patterns, accommodating various use cases and architectures.</li> <li>Efficiency: Optimized for high-throughput and low-latency messaging, ensuring performance.</li> </ul>"},{"location":"server/devices/#usage","title":"Usage","text":"<p>Using ZeroMQ devices is optional. However, if your application requires multiple servers or workers, employing a device becomes necessary. ZMAG provides support for both scenarios. You can control whether a device is used and its configuration through settings:</p> <ul> <li>Starting a Device: Set <code>proxy = true</code> if the device runs within the application.</li> </ul> <p>Starting a Device</p> <ul> <li><code>proxy = true</code></li> </ul> <ul> <li>Attaching to Device: If the device is running in a separate environment, set <code>proxy = false</code> and <code>attach = true</code>.</li> </ul> <p>Attaching to Device</p> <ul> <li><code>proxy = false</code></li> <li><code>attach = true</code></li> </ul> <ul> <li>Running a Single Server: If you want to run a single server without a device, set <code>proxy = false</code>, <code>attach = false</code>, and <code>workers = 1</code>.</li> </ul> <p>Single Server</p> <ul> <li><code>workers = 1</code></li> <li><code>proxy = false</code></li> <li><code>attach = false</code></li> </ul>"},{"location":"server/devices/#settings","title":"Settings","text":"<p>Example Configuration:</p> config/spoc.toml<pre><code># ZeroMQ Configuration\n[spoc.zmq]\n...\nworkers = 2\nproxy = true\nattach = true\n...\n</code></pre> <p>By leveraging ZeroMQ devices, you can build robust and efficient messaging systems tailored to your application's needs.</p>"},{"location":"server/forwarder/","title":"Forwarder \u2014 <code>Pub</code> and <code>Sub</code>","text":"<p>In this guide, you'll learn how to implement <code>PUB/SUB</code> operations. Optionally, you can utilize the GraphQL schema to obtain information for publishing.</p>"},{"location":"server/forwarder/#pub-operations","title":"<code>PUB</code> Operations","text":"<p>Must be inside a file named <code>publishers.py</code></p> <p>Publishers use the function's name as the default <code>channel</code> for clients to subscribe to. However, you have two options for customizing the channel:</p> <ol> <li>Specify the channel in the decorator.</li> <li>Dynamically set the channel in the response's <code>meta</code> within the function (Not recommended).</li> </ol>"},{"location":"server/forwarder/#example","title":"Example","text":"publishers.py<pre><code>@zmag.pub  # or zmag.pub(seconds=5)\nasync def topic():  # `topic` is the channel\n    response = zmag.Data()\n    response.body = {\"message\": \"hello world\"}\n    return response\n\n# GraphQL Query\n@zmag.pub(channel=\"custom_name\")\nasync def graphql(context):\n    gql_query = \"query { books { id title } }\"\n    results = await context.schema.execute(gql_query)\n    response = zmag.Data()\n    response.body = results.data\n    return response\n\n# Custom Channel\n@zmag.pub(seconds=5)\nasync def generic():\n    response = zmag.Data()\n    response.meta[\"channel\"] = \"my_channel\" # won't register\n    response.body = {\"message\": \"hello world\"}\n    return response\n</code></pre>"},{"location":"server/forwarder/#settings","title":"Settings","text":"config/spoc.toml<pre><code>[spoc.zmq]\n...\ndevice = \"forwarder\"  # options: queue, forwarder, streamer\n...\n</code></pre> python main.py runserverINFO    -  Starting Application . . ."},{"location":"server/forwarder/#list-channels","title":"List Channels","text":"<p>If you set the channel name dynamically, it will not be registered in the channels list.</p> python main.py channels\u2014 custom_name\u2014 generic\u2014 topic"},{"location":"server/intro/","title":"Server Introduction","text":"<p>To get started with the ZMAG server, first install the package:</p> <pre><code>python -m pip install \"zmag[server]\"\n</code></pre> <p>In ZMAG, the server represents the backend. Some ZeroMQ tutorials use the terms \"backend\" and \"frontend\" instead of \"server\" and \"client\" because not everything is always a straightforward server/client model. However, to maintain a beginner-friendly and consistent naming convention, we'll stick with \"server\" and \"client.\"</p> <p>This naming convention is also chosen because the server and client are symmetrically structured.</p> For example... As compared to... <code>client</code> <code>frontend</code> <code>server</code> <code>backend</code>"},{"location":"server/intro/#devices-types","title":"Devices (Types)","text":"<ul> <li><code>Queue</code></li> <li><code>Streamer</code></li> <li><code>Forwarder</code></li> </ul>"},{"location":"server/intro/#bidirectional-information-flow-requestresponse","title":"Bidirectional Information Flow (Request/Response)","text":"<pre><code>flowchart LR;\n    D[Request] &lt;--&gt; E[Response];\n    A[Client / Request] &lt;--&gt; B((Queue)) &lt;--&gt; C[Server / Response];</code></pre>"},{"location":"server/intro/#unidirectional-information-flow-pushpull","title":"Unidirectional Information Flow (Push/Pull)","text":"<pre><code>flowchart LR;\n    D[Push] --&gt; E[Pull];\n    A[Server / Push] --&gt; B((Streamer)) --&gt; C[Client / Pull];</code></pre>"},{"location":"server/intro/#unidirectional-information-flow-publishsubscribe","title":"Unidirectional Information Flow (Publish/Subscribe)","text":"<pre><code>flowchart LR;\n    D[Publish] --&gt; E[Subscribe];\n    A[Server / Publish] --&gt; B((Forwarder)) --&gt; C[Client / Subscribe];</code></pre>"},{"location":"server/queue/","title":"<code>Queue</code>","text":"<p>In this guide, you'll learn how to run the server in <code>Request/Response</code> mode. To create operations for the <code>Queue</code> mode look at GraphQL Operations.</p> <p>Here will learn how to configure the server to run on Queue mode which its very simple set the <code>device</code> to <code>queue</code></p>"},{"location":"server/queue/#settings","title":"Settings","text":"config/spoc.toml<pre><code>[spoc.zmq]\n...\ndevice = \"queue\"  # options: queue, forwarder, streamer\n...\n</code></pre> python main.py runserverINFO    -  Starting Application . . ."},{"location":"server/streamer/","title":"Streamer \u2014 <code>Push</code> and <code>Pull</code>","text":"<p>In this guide, you'll learn how to implement <code>PUSH/PULL</code> operations. Optionally, you can utilize the GraphQL schema to obtain information for pushing.</p>"},{"location":"server/streamer/#push-operations","title":"<code>PUSH</code> Operations","text":"<p>Must be inside a file named <code>pushers.py</code></p> <p>Pushers operate similarly to publishers, but they do not use channels. Instead, the workload is distributed using a round-robin load balancing algorithm.</p>"},{"location":"server/streamer/#example","title":"Example","text":"pushers.py<pre><code>@zmag.push\nasync def task_one(context):\n    gql_query = \"query { books { id title } }\"\n    results = await context.schema.execute(gql_query)\n    response = zmag.Data()\n    response.body = results.data\n    return response\n\n@zmag.push(seconds=5)\nasync def task_two():\n    response = zmag.Data()\n    response.body = {\"message\": \"hello world\"}\n    return response\n</code></pre>"},{"location":"server/streamer/#settings","title":"Settings","text":"config/spoc.toml<pre><code>[spoc.zmq]\n...\ndevice = \"streamer\"  # options: queue, forwarder, streamer\n...\n</code></pre> python main.py runserverINFO    -  Starting Application . . ."},{"location":"server/streamer/#list-tasks","title":"List Tasks","text":"<p>The task will be displayed as <code>&lt;app_name&gt;.&lt;task_name&gt;(time = &lt;time_in_seconds&gt;)</code>.</p> python main.py tasks\u2014 demo.task_one(time=0)\u2014 demo.task_two(time=5)"},{"location":"server/config/environment/","title":"Environments","text":"<p>The following settings are used to configure your application for different environments such as <code>development</code>, <code>staging</code>, and <code>production</code>. Each environment has its own configuration file that specifies environment-specific settings.</p> <pre><code>from spoc import settings\n\nsettings.ENV\n</code></pre>"},{"location":"server/config/environment/#settings-locations","title":"Settings Locations","text":"<p>The configuration files for different environments are organized under the <code>config</code> directory, specifically within the <code>.env</code> subdirectory. This structure helps to keep environment-specific settings separate and easily manageable.</p> <pre><code>root/\n|-- config/                      --&gt; &lt;Directory&gt; - Configurations.\n|    |-- ...\n|    |-- .env/                   --&gt; &lt;Directory&gt; - Environments.\n|    |   |-- development.toml    --&gt; &lt;File&gt; - Development Environment Settings.\n|    |   |-- production.toml     --&gt; &lt;File&gt; - Production Environment Settings.\n|    |   `-- staging.toml        --&gt; &lt;File&gt; - Staging Environment Settings.\n|    `-- ...\n`-- etc...\n</code></pre>"},{"location":"server/config/environment/#explanation","title":"Explanation","text":"<ul> <li>development.toml: Contains settings specific to the development environment, such as debug configurations, development database connections, and more.</li> <li>production.toml: Holds settings tailored for the production environment, including optimized configurations for performance, security, and live data handling.</li> <li>staging.toml: Used for staging environments to mimic the production environment as closely as possible while allowing for final testing and validation.</li> </ul>"},{"location":"server/config/environment/#key-sections","title":"Key Sections","text":"<ul> <li><code>[env]</code>: General environment settings that apply to the current environment.</li> <li><code>[env.zmq]</code>: Configuration specific to ZeroMQ.</li> </ul>"},{"location":"server/config/environment/#development","title":"Development","text":"<p>The <code>development.toml</code> file is used to configure settings for the development environment. This typically includes settings that are more permissive and allow for debugging and testing during development.</p> config/.env/development.toml<pre><code>[env] # Environment Settings\n\n[env.zmq] # ZeroMQ Configuration\npublic_key = \"public-key-x7i+CS&lt;BVZMJyXEX)H8?31k5o)?mQ\"\nsecret_key = \"secret-key-x(&lt;$ES*$pZ3UmIPEIy+lt1qNY!!Kn\"\nserver_key = \"server-key-QAvkkf}^Y5OVu=R?S&lt;V9Xi-Y!Zm4q\"\n</code></pre>"},{"location":"server/config/environment/#staging","title":"Staging","text":"<p>The <code>staging.toml</code> file configures the staging environment, which is used for testing the application in a production-like setting without affecting the live environment. It often mirrors production settings with minor adjustments.</p> config/.env/staging.toml<pre><code>[env] # Environment Settings ...\n</code></pre>"},{"location":"server/config/environment/#production","title":"Production","text":"<p>The <code>production.toml</code> file includes settings optimized for the live production environment. This configuration emphasizes security, performance, and stability to ensure the application runs smoothly in a live setting.</p> config/.env/production.toml<pre><code>[env] # Environment Settings ...\n</code></pre>"},{"location":"server/config/environment/#summary","title":"Summary","text":"<p>By organizing environment-specific settings into distinct files, you can easily switch between configurations for <code>development</code>, <code>staging</code>, and <code>production</code>. This structure also ensures that sensitive information, such as keys and environment variables, is properly managed and isolated per environment.</p>"},{"location":"server/config/environment/#using-os-environment-variables","title":"Using <code>OS</code> Environment Variables","text":"<p>For enhanced security and flexibility, you can use environment variables to manage your ZMAG keys.</p> <pre><code>export ZMAG_PUBLIC_KEY=\"public-key-x7i+CS&lt;BVZMJyXEX)H8?31k5o)?mQ\"\nexport ZMAG_SECRET_KEY=\"secret-key-x(&lt;XES*xpZ3UmIPEIy+lt1qNY!!Kn\"\nexport ZMAG_SERVER_KEY=\"server-key-QAvkkf}^Y5OVu=R?S&lt;V9Xi-Y!Zm4q\"\n</code></pre>"},{"location":"server/config/settings/","title":"Settings","text":"<p>The following settings control the configuration of your ZMAG application, including installed apps, extra options, and specific configurations for different environments.</p> <pre><code>from spoc import settings\n\nprint(settings.__dir__())\n</code></pre>"},{"location":"server/config/settings/#settings-locations","title":"Settings Locations","text":"<pre><code>root/\n|--  config/                    --&gt; &lt;Directory&gt; - Configurations.\n|    |-- ...\n|    |-- settings.py            --&gt; &lt;File&gt; - Pythonic Settings.\n|    `-- spoc.toml              --&gt; &lt;File&gt; - Spoc Settings.\n`-- etc...\n</code></pre>"},{"location":"server/config/settings/#python","title":"Python","text":"Key Description <code>INSTALLED_APPS</code> A list of ZMAG <code>apps</code> that are currently enabled and in use within the project. <code>PLUGINS</code> Additional <code>components</code> for the application."},{"location":"server/config/settings/#settingspy","title":"<code>settings.py</code>","text":"<p>Below is an example of a Python settings file (<code>settings.py</code>) used to configure your ZMAG project.</p> config/settings.py<pre><code>import pathlib\n\n# Base Directory\nBASE_DIR = pathlib.Path(__file__).parents[1]  # (1)\n\n# Installed APPS\nINSTALLED_APPS: list = [\"app_one\", \"app_two\"]  # (2)\n\n# Additional Components\nPLUGINS: dict = {  # (3)\n    \"extensions\": [],\n    \"permissions\": [],\n    \"on_startup\": [],\n    \"on_shutdown\": [],\n}\n</code></pre> <ol> <li>Base Directory: Defines the root directory of the project, setting the base path for all file operations.</li> <li>INSTALLED_APPS: Specifies the ZMAG applications that are currently installed and active in the project.</li> <li>PLUGINS: Defines additional configurations, including extensions, permissions, and event handlers for startup and shutdown.</li> </ol>"},{"location":"server/config/settings/#toml","title":"TOML","text":"<p>The <code>spoc.toml</code> file provides a declarative way to configure different aspects of your ZMAG project, from operating modes to specific settings for GraphQL and ZeroMQ.</p> Key Group Description <code>mode</code> <code>n/a</code> Specifies the environment mode for the application, such as (<code>development</code>, <code>production</code>, or <code>staging</code>). <code>debug</code> <code>n/a</code> Enables or disables debug mode for the server, providing more detailed error messages and live reloading. <code>authentication</code> <code>n/a</code> Determines if authentication is required for both <code>frontend</code> and <code>backend</code> in ZeroMQ communications. <code>max_depth</code> <code>graphql</code> Sets the maximum allowed depth for nested objects in a GraphQL query to control query complexity. <code>introspection</code> <code>graphql</code> Enables querying of the current API schema to discover available resources and their structures. <code>items_per_page</code> <code>graphql</code> Defines the maximum number of items returned per page in paginated GraphQL responses. <code>node</code> <code>zmq</code> Name for the ZeroMQ <code>node</code>. <code>workers</code> <code>zmq</code> Specifies the number of worker processes or threads to handle ZeroMQ messaging tasks. <code>proxy</code> <code>zmq</code> Indicates whether to start a ZMQ proxy/broker <code>device</code> for message routing. <code>attach</code> <code>zmq</code> Determines if the server should be attached to a ZMQ proxy/broker <code>device</code> for message forwarding. <code>thread</code> <code>zmq</code> Configures whether to use threads or processes for ZeroMQ worker operations. <code>device</code> <code>zmq</code> Specifies the messaging pattern to use (<code>queue</code>, <code>forwarder</code>, or <code>streamer</code>) within ZeroMQ. <code>server</code> and <code>client</code> <code>zmq</code> Defines the connection strings for the ZeroMQ server and client endpoints. <code>permissions</code> <code>plugins</code> Lists the permission classes that control access to different parts of the application. <code>extensions</code> <code>plugins</code> Specifies the GraphQL extensions to enhance the API's functionality, such as custom directives or resolvers. <code>apps</code> <code>apps</code> Lists the installed apps for each environment mode, allowing customization of active apps per mode."},{"location":"server/config/settings/#spoctoml","title":"<code>spoc.toml</code>","text":"<p>Here is an example of a <code>spoc.toml</code> configuration file:</p> config/spoc.toml<pre><code># Server Configuration\n[spoc]\nmode = \"development\"  # options: production, development, staging\ndebug = true\nauthentication = false\n\n# GraphQL Configuration\n[spoc.graphql]\nmax_depth = 4\nintrospection = true\nitems_per_page = 100\n\n# ZeroMQ Configuration\n[spoc.zmq]\nnode = \"service-name\"\nworkers = 1\nproxy = true\nattach = true\nthread = false\ndevice = \"forwarder\"  # options: queue, forwarder, streamer\nserver = \"tcp://127.0.0.1:5556\"\nclient = \"tcp://127.0.0.1:5555\"\n\n# Installed Apps by Mode\n[spoc.apps]\nproduction = [\"app_one\"]\ndevelopment = [\"app_two\", \"app_three\"]\nstaging = [\"app_four\"]\n\n# Additional Components\n[spoc.plugins]\n# Plugins\nextensions = [\"my_app.extensions.MyExtension\"]\npermissions = [\"my_app.permissions.MyPermission\"]\n\n# Event Hooks\non_startup = [\"my_app.events.on_startup\"]\non_shutdown = [\"my_app.events.on_shutdown\"]\n</code></pre> <p>Explanations:</p> <ul> <li>mode: Specifies the running environment, allowing for different configurations in development, staging, or production.</li> <li>GraphQL Settings: Controls aspects of GraphQL, such as query depth and pagination limits.</li> <li>ZeroMQ Settings: Configures the messaging patterns and server/client details for ZeroMQ operations.</li> <li>Apps: Define which apps are enabled based on the current mode and user-defined settings.</li> <li>Plugins: Define which additional features are enabled.</li> <li>Event Hooks: Allows specification of functions that should run on startup and shutdown, enabling custom initialization and cleanup logic.</li> </ul>"},{"location":"server/config/variables/","title":"Constant Variables","text":"<p>The following variables are configured within the <code>zmag.settings</code> module and can be used to control various aspects of your application's behavior.</p> <pre><code>from zmag import settings\n</code></pre>"},{"location":"server/config/variables/#constants","title":"Constants","text":"<ul> <li><code>BASE_DIR</code></li> <li><code>DEBUG</code></li> <li><code>MODE</code></li> <li><code>SPOC</code></li> <li><code>ENV</code></li> </ul> <p>These variables provide a centralized way to manage your application's settings, making it easy to adapt to different environments or configurations.</p>"},{"location":"server/config/variables/#base_dir","title":"<code>BASE_DIR</code>","text":"<p>Description: Represents the base directory of your project. This is often used as a reference point for constructing paths to other directories and files within the project.</p> <pre><code>from zmag import settings\n\nSOME_PATH = settings.BASE_DIR / \"some-path\"\n</code></pre>"},{"location":"server/config/variables/#debug","title":"<code>DEBUG</code>","text":"<p>Description: A boolean variable that indicates whether the application is running in debug mode. This is typically used to enable more verbose logging or debugging features during development.</p> <pre><code>from zmag import settings\n\nif settings.DEBUG:\n    print(\"Debug Enabled\")\nelse:\n    print(\"Debug Disabled\")\n</code></pre>"},{"location":"server/config/variables/#mode","title":"<code>MODE</code>","text":"<p>Description: Defines the current operational mode of the application (e.g., <code>production</code>, <code>staging</code>, <code>development</code>). This is useful for enabling or disabling features based on the environment in which the application is running.</p> <pre><code>from zmag import settings\n\nmatch settings.MODE:\n    case \"production\":\n        print(\"Production Mode\")\n    case \"staging\":\n        print(\"Staging Mode\")\n    case \"development\":\n        print(\"Development Mode\")\n</code></pre>"},{"location":"server/config/variables/#spoc","title":"<code>SPOC</code>","text":"<p>Description: A dictionary-like object containing specific configuration settings for your application. This can be used to store and retrieve custom configuration values, such as feature flags or integration settings.</p> <pre><code>from zmag import settings\n\nuse_authentication = settings.SPOC.get(\"authentication\", False)\n</code></pre>"},{"location":"server/config/variables/#env","title":"<code>ENV</code>","text":"<p>Description: A dictionary containing environment-specific variables. This is often used to retrieve sensitive information such as API keys or environment variables required for the application to function.</p> <pre><code>from zmag import settings\n\nprint(settings.ENV[\"my-variable-name\"])\n</code></pre>"},{"location":"server/graphql/built-in/","title":"Extending GraphQL Operations","text":"<p>Tip</p> <p>Utilize these tools to effectively create and manage GraphQL operations.</p>"},{"location":"server/graphql/built-in/#mutation-tools-reference","title":"Mutation Tools \u2014 Reference","text":"<ul> <li><code>zmag.Mutation</code> \u2014 Represents a GraphQL mutation response, handling the outcome of mutation operations.</li> <li><code>zmag.Error</code> \u2014 A structured format for GraphQL error messages to be used in error responses.</li> <li><code>zmag.Errors</code> \u2014 A comprehensive response object for handling multiple GraphQL errors.</li> <li><code>zmag.input_error</code> \u2014 A simplified error handler for mutation errors.</li> </ul>"},{"location":"server/graphql/built-in/#query-tools-reference","title":"Query Tools \u2014 Reference","text":"<ul> <li><code>zmag.Record</code> \u2014 A utility for returning either a <code>single</code> object or a <code>list</code> of objects, depending on the query response, making it flexible for various use cases.</li> <li><code>zmag.BaseEdge</code> \u2014 Base <code>edge</code> that allows defining the <code>computed</code> field instead of a generic <code>JSON</code>.</li> <li><code>zmag.Edge</code> \u2014 Optimizes data retrieval by defining edges in GraphQL queries and included a generic <code>JSON</code> based <code>computed</code> field.</li> <li><code>zmag.edge</code> \u2014 A utility for returning edges in GraphQL queries</li> </ul>"},{"location":"server/graphql/built-in/#input-tools-reference","title":"Input Tools \u2014 Reference","text":"<ul> <li><code>zmag.Pagination</code> \u2014 An input type designed to manage pagination, allowing efficient navigation and retrieval of database records.</li> <li><code>zmag.Selector</code> \u2014 A tool for selecting specific database records, enabling targeted data manipulation.</li> </ul>"},{"location":"server/graphql/built-in/#examples","title":"Examples","text":"inputs.pytypes.py <pre><code>import zmag\n\nBook = zmag.input(\"Book\")\n\n# Create your &lt;input&gt; here.\n@Book\nclass Create(zmag.Input):\n    title: str    \n</code></pre> <pre><code>from dataclasses import dataclass\nfrom typing import Annotated, TypeAlias, TypeVar\n\nimport zmag\n\n# ForwardRef\nT = TypeVar(\"T\")\nRef: TypeAlias = Annotated[T, zmag.lazy_type(\".types\")]\n\n# Create your &lt;types&gt; here.\n@dataclass\nclass Book(zmag.Type):\n    title: str | None = None\n    author: Ref[\"Author\"] | None = None\n\n\n@dataclass\nclass Author(zmag.Type):\n    name: str | None = None\n    books: list[Book] | None = None\n</code></pre>"},{"location":"server/graphql/built-in/#mutation-example","title":"Mutation Example","text":"<p>This example demonstrates how to use <code>zmag.Mutation</code>, <code>zmag.Errors</code>, and <code>zmag.Error</code> to handle mutations in GraphQL. We will also utilize the previously defined <code>types</code> and <code>inputs</code>.</p> graphql.py<pre><code>import zmag\nfrom . import inputs, types\n\n@zmag.gql\nclass Graphql:\n    \"\"\"Books API\"\"\"\n\n    class Meta:\n        app = None\n        model = types.Book\n\n    class Mutation:\n        async def create(self, form: inputs.Create) -&gt; zmag.Mutation[types.Book]:\n            # Check if the input is not valid\n            if not form.input.is_valid:\n                return zmag.Mutation(\n                    error=zmag.Errors(\n                        messages=[zmag.Error(**e) for e in form.input.errors],\n                    ),\n                )\n\n            # Process valid input\n            data = form.input.dict()\n            return zmag.Mutation(\n                item=types.Book(\n                    title=data.get(\"title\"),\n                    author=types.Author(name=\"Michael Crichton\"),\n                ),\n            )\n</code></pre> <p>Example Usage in GraphQL</p> <pre><code>mutation MyMutation {\n  bookCreate(form: {title: \"Jurassic Park\"}) {\n    # On success\n    item {\n      title\n      author {\n        name\n      }\n    }\n    # On error\n    error {\n      messages {\n        field\n        type\n        text\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"server/graphql/built-in/#mutation-simplified-error-example","title":"Mutation Simplified Error Example","text":"<p>To simplify error handling, you can use the built-in <code>zmag.input_error</code> tool. This example shows how to streamline error responses when input validation fails.</p> <pre><code>import zmag\n\nasync def create(...):\n    # Check if the input is not valid\n    if not form.input.is_valid:\n        return zmag.input_error(form.input.errors)\n\n    # Continue with valid input processing\n    ...\n</code></pre>"},{"location":"server/graphql/built-in/#query-record-example","title":"Query <code>Record</code> Example","text":"<p>This example demonstrates how to use <code>zmag.Record</code>.</p> <pre><code>... # Graphql\n... # Meta\n\nclass Query:\n    async def one_record(self) -&gt; zmag.Record[types.Book]:\n        return zmag.Record(\n            item=types.Book(title=\"The Great Gatsby\"), \n            is_many=False\n        )\n\n    async def many_records(self) -&gt; zmag.Record[types.Book]:\n        return zmag.Record(\n            items=[types.Book(title=\"The Great Gatsby\")], \n            is_many=True\n        )\n</code></pre> <p>Example Usage in GraphQL</p> <p>Usage with <code>item</code></p> <pre><code>query MyQuery {\n  bookOneRecord {\n    isMany\n    item {\n      title\n    }\n  }\n}\n</code></pre> <p>Example Usage in GraphQL</p> <p>Usage with <code>items</code></p> <pre><code>query MyQuery {\n  bookManyRecords {\n    isMany\n    items {\n      title\n    }\n  }\n}\n</code></pre>"},{"location":"server/graphql/built-in/#query-baseedge-example","title":"Query <code>BaseEdge</code> Example","text":"<p>This example demonstrates how to use <code>zmag.BaseEdge</code> to connect edges with a predefined computed <code>Type</code>. The <code>BaseEdge</code> is utilized when the edge requires a specific computed type to be associated with it, allowing for more structured data retrieval.</p> <pre><code>@dataclass\nclass Computed(zmag.Type):\n    total_views: int | None = None\n</code></pre> <pre><code># GraphQL query definition\nclass Query:\n    async def many_records(self) -&gt; zmag.BaseEdge[types.Book, types.Computed]:\n        # Implementation logic here\n        ...\n</code></pre>"},{"location":"server/graphql/built-in/#query-edge-example","title":"Query <code>Edge</code> Example","text":"<p>This example shows how to use <code>zmag.Edge</code>, a more generic type of edge. Here, the computed value is stored in a JSON format, providing flexibility in what data is returned with each edge.</p> <pre><code># GraphQL query definition\nclass Query:\n    async def many_records(self) -&gt; zmag.Edge[types.Book]:\n        # Implementation logic here\n        ...\n</code></pre>"},{"location":"server/graphql/built-in/#query-pagination-example","title":"Query <code>Pagination</code> Example","text":"<p>This example illustrates how to implement <code>zmag.Pagination</code> to handle paginated queries. You can configure the <code>items_per_page</code> setting through a configuration file, which sets the maximum <code>limit</code> a user can request, ensuring efficient data retrieval and performance.</p> <pre><code># GraphQL query definition\nclass Query:\n    async def many_records(self, pagination: zmag.Pagination) -&gt; zmag.JSON:\n        data = pagination.input.data\n        return {\n            \"page\": data.page,\n            \"limit\": data.limit,\n            \"sort_by\": data.sort_by,\n        }\n</code></pre>"},{"location":"server/graphql/built-in/#query-selector-example","title":"Query <code>Selector</code> Example","text":"<p>This example demonstrates the use of <code>zmag.Selector</code> for selecting specific records. The <code>Selector</code> enables precise querying by allowing users to specify which records to retrieve based on provided <code>id</code> or <code>ids</code>.</p> <pre><code># GraphQL query definition\nclass Query:\n    async def one_record(self, select: zmag.Selector) -&gt; str:\n        return select.input.data.id\n\n    async def many_records(self, select: zmag.Selector) -&gt; list[str]:\n        return select.input.data.ids\n</code></pre> <p>Example Usage in GraphQL with a Single Item:</p> <pre><code>query MyQuery {\n  bookOneRecord(select: {id: 1})\n}\n</code></pre> <p>Example Usage in GraphQL with Multiple Items:</p> <pre><code>query MyQuery {\n  bookManyRecords(select: {ids: [1, 2, 3]})\n}\n</code></pre>"},{"location":"server/graphql/extensions/","title":"Extensions","text":"<p>ZMAG provides a wrapper for Strawberry's <code>Extension</code>.</p> <p>strawberry</p> <p>To create custom extensions or learn more about how they work, visit the official documentation here.</p> <pre><code># -*- coding: utf-8 -*-\n\"\"\"\nExtensions\n\"\"\"\n\nfrom types import SimpleNamespace\n\nfrom zmag import BaseExtension\n\n\nclass MyExtension(BaseExtension):\n    \"\"\"GraphQL Extension\"\"\"\n\n    async def on_execute(self):\n        \"\"\"On Execute\"\"\"\n        user = self.execution_context.context.get(\"user\")\n        user = SimpleNamespace(**(user or {}))\n\n        # Set-User (Context)\n        self.execution_context.context[\"user\"] = user\n\n        yield\n</code></pre>"},{"location":"server/graphql/inputs/","title":"GraphQL Inputs","text":"<p>The code must be placed in a file named <code>inputs.py</code> or within a folder named <code>inputs</code> located in the Application directory.</p>"},{"location":"server/graphql/inputs/#input-tools-reference","title":"Input Tools \u2014 Reference","text":"<ul> <li><code>zmag.Input</code> \u2014 Base class for defining inputs.</li> <li><code>zmag.input</code> \u2014 Initializes input group.</li> <li><code>zmag.value</code> \u2014 Configures input field settings.</li> <li><code>zmag.clean</code> \u2014 Defines cleaning functions or rules.</li> <li><code>zmag.Form</code> \u2014 Represents an input response.</li> </ul> <p>Tip</p> <p>Tools used for creating GraphQL <code>INPUT</code> types.</p>"},{"location":"server/graphql/inputs/#using-zmaginput-and-zmaginput","title":"Using <code>zmag.Input</code> and <code>zmag.input</code>","text":"inputs.py<pre><code>import zmag\n\nform = zmag.input(\"Form\")\n\n@form\nclass Create(zmag.Input): ... # FormCreate\n\n@form\nclass Update(zmag.Input): ... # FormUpdate\n</code></pre>"},{"location":"server/graphql/inputs/#examples","title":"Examples","text":""},{"location":"server/graphql/inputs/#required-field","title":"Required Field","text":"<p>A required field with no default value; the field must be filled.</p> <pre><code>import zmag\n\nAuthor = zmag.input(\"Author\")\n\n@Author\nclass MyForm(zmag.Input):\n    x: str = zmag.value(required=True)\n</code></pre>"},{"location":"server/graphql/inputs/#dynamic-default-value","title":"Dynamic Default Value","text":"<p>A field with a default value, optionally using a function for initialization.</p> <pre><code>import zmag\n\nAuthor = zmag.input(\"Author\")\n\n@Author\nclass MyForm(zmag.Input):\n    \"\"\"GraphQL Form with Dynamic Default Value\"\"\"\n\n    y: str = zmag.value(default=\"Some Value\")\n    # OR\n    y: str = zmag.value(default=lambda: \"Some Value\")\n</code></pre>"},{"location":"server/graphql/inputs/#deprecated-field","title":"Deprecated Field","text":"<p>A deprecated field, indicating it should no longer be used.</p> <pre><code>import zmag\n\nAuthor = zmag.input(\"Author\")\n\n@Author\nclass MyForm(zmag.Input):\n    \"\"\"GraphQL Form with Deprecated Field\"\"\"\n\n    z: str = zmag.value(deprecation_reason=\"This field is deprecated.\")\n</code></pre>"},{"location":"server/graphql/inputs/#complex-field-with-validation-and-cleaning","title":"Complex Field with Validation and Cleaning","text":"<p>A complex field setup demonstrating validation, cleaning, and transformation of input data.</p> <pre><code>import zmag\n\nAuthor = zmag.input(\"Author\")\n\n@Author\nclass MyForm(zmag.Input):\n    \"\"\"GraphQL Form with Complex Field Setup\"\"\"\n\n    email: str = zmag.value(\n        regex={\n            # Regex pattern for email validation.\n            r\"[\\w\\.-]+@[\\w\\.-]+\": \"Invalid email address\"\n        },\n        rules=[\n            # Custom validation rule for the field.\n            (lambda v: v.startswith(\"demo\") or \"Invalid input\")\n        ],\n        clean=zmag.clean(\n            regex=[\n                # Replace text in the cleaning phase.\n                (r\"^hello\", \"hola\"),\n                (r\"com\", \"api\"),\n            ],\n            rules=[\n                # Transform the value after applying regex replacements.\n                (lambda v: v.upper())\n            ],\n        ),\n    )\n</code></pre>"},{"location":"server/graphql/inputs/#example-usage","title":"Example Usage","text":"<p>The built-in <code>input: Form</code> attribute provides flexible access to the input data, allowing you to manipulate and retrieve it in various formats.</p> graphql.py<pre><code>@zmag.gql\nclass Graphql:\n    ...\n\n    class Mutation:\n        async def create(self, form: MyForm | None) -&gt; None:\n            if form and form.input.is_valid:\n                print(form.input)\n                print(form.input.clean())\n                print(form.input.dict(True))\n            return None\n</code></pre>"},{"location":"server/graphql/operations/","title":"GraphQL Operations","text":"<p>The code must be placed in a file named <code>graphql.py</code> or within a folder named <code>graphql</code> located in the Application directory.</p> graphql.py<pre><code>import zmag\n\n# Create your API (GraphQL) here.\n@zmag.gql\nclass Graphql:\n    class Meta: ...\n    class Query: ...\n    class Mutation: ...\n</code></pre>"},{"location":"server/graphql/operations/#operations-tools-reference","title":"Operations Tools \u2014 Reference","text":"<ul> <li><code>Meta</code></li> <li><code>Query</code></li> <li><code>Mutation</code></li> </ul>"},{"location":"server/graphql/operations/#meta-optional","title":"Meta (Optional)","text":"<p>The <code>Meta</code> class can be used to customize the naming and behavior of these GraphQL operations.</p> <ul> <li><code>app</code> (<code>str | bool | None</code>): Specifies the application name or identifier.</li> <li><code>model</code> (<code>str | type | None</code>): Associates the GraphQL operations with a model. This can be a string representing the model name or an actual <code>type</code> class.</li> </ul>"},{"location":"server/graphql/operations/#examples","title":"Examples","text":""},{"location":"server/graphql/operations/#without-meta-default","title":"Without <code>Meta</code> (default)","text":"<p>When the <code>Meta</code> class is not used:</p> <pre><code>@zmag.gql\nclass Graphql:\n    async def detail(self) -&gt; str:\n        return \"Detail\"\n</code></pre> <p>GraphQL Field Name:</p> <pre><code>demoDetail\n</code></pre> <p>Explanation: The GraphQL field name is automatically generated based on the method name <code>detail</code> and package/application name <code>demo</code>.</p>"},{"location":"server/graphql/operations/#with-model","title":"With <code>model</code>","text":"<p>When the <code>Meta</code> class specifies a <code>model</code>:</p> <pre><code>from . import types\n\n@zmag.gql\nclass Graphql:\n    class Meta:\n        model = types.Book\n</code></pre> <p>GraphQL Field Name:</p> <pre><code>demoBookDetail\n</code></pre> <p>Explanation: The GraphQL field name is prefixed with the model name (<code>Book</code>), resulting in <code>demoBookDetail</code>.</p>"},{"location":"server/graphql/operations/#with-app-set-to-none","title":"With <code>app</code> Set to <code>None</code>","text":"<p>When the <code>Meta</code> class specifies <code>app</code> as <code>None</code>:</p> <pre><code>@zmag.gql\nclass Graphql:\n    class Meta:\n        app = None\n        ...\n</code></pre> <p>GraphQL Field Name:</p> <pre><code>detail\n</code></pre> <p>Explanation: The <code>app</code> value is ignored, so the GraphQL field name is based directly on the method name <code>detail</code>.</p>"},{"location":"server/graphql/operations/#with-custom-app","title":"With custom <code>app</code>","text":"<pre><code>@zmag.gql\nclass Graphql:\n    class Meta:\n        app = \"custom\"\n        ...\n</code></pre> <p>GraphQL Field Name:</p> <pre><code>customDetail\n</code></pre> <p>Explanation: The GraphQL field name is automatically generated based on the method name <code>detail</code> and provided app name <code>custom</code>.</p>"},{"location":"server/graphql/operations/#full-example","title":"Full Example","text":"<pre><code>import zmag\n\n@zmag.gql\nclass Graphql:\n\n    class Meta:\n        app = True\n        model = \"Book\"\n\n    class Query:\n        async def detail(self) -&gt; str:\n            return \"Detail (Query)\"\n\n    class Mutation:\n        async def create(self) -&gt; str:\n            return \"Create (Mutation)\"\n</code></pre>"},{"location":"server/graphql/permissions/","title":"Permissions","text":"<p>ZMAG provides a wrapper for Strawberry's <code>Permission</code> and <code>Info</code>.</p> <p>strawberry</p> <p>To create custom permissions or learn more about how they work, visit the official documentation here.</p> <pre><code># -*- coding: utf-8 -*-\n\"\"\"\nPermission\n\"\"\"\n\nfrom typing import Any\n\nfrom zmag import BasePermission, InfoGraphql\n\n\nclass MyPermission(BasePermission):\n    \"\"\"Check If User Is Authorized\"\"\"\n\n    message = \"User is not authorized\"  # Unauthorized\n\n    def has_permission(\n        self,\n        source: Any,\n        info: InfoGraphql,\n        **kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"Check GraphQL's Info Context\"\"\"\n\n        operation = info.field_name  # info.python_name\n        user = info.context.get(\"user\")\n\n        print(\"Checking Perms\", operation, user)\n\n        if user:\n            return True\n        return False\n</code></pre>"},{"location":"server/graphql/scalars/","title":"Scalars","text":"<p>ZMAG provides wrappers for various scalars, including from Strawberry, to centralize and simplify imports. This reduces the need for multiple import statements in Python files, keeping the code cleaner and more streamlined.</p> <p>strawberry</p> <p>To create custom scalars or learn more about how they work, visit the official documentation here.</p> GraphQL Python <code>String</code> <code>str</code> <code>Int</code> <code>int</code> <code>Float</code> <code>float</code> <code>Boolean</code> <code>bool</code> <code>ID</code> <code>zmag.id</code> <code>Decimal</code> <code>zmag.decimal</code> <code>Date</code> <code>zmag.date</code> <code>Time</code> <code>zmag.time</code> <code>DateTime</code> <code>zmag.datetime</code> <code>UUID</code> <code>zmag.uuid</code> <code>JSON</code> <code>zmag.json</code>"},{"location":"server/graphql/scalars/#example","title":"Example","text":"<pre><code>from dataclasses import dataclass\nimport zmag\n\n@dataclass\nclass Product(zmag.Type):\n    id: zmag.id\n    serial: zmag.uuid\n    name: str\n    stock: int\n    weight: float\n    is_available: bool\n    available_from: zmag.date\n    same_day_shipping_before: zmag.time\n    created_at: zmag.datetime\n    price: zmag.decimal\n    metadata: zmag.json\n</code></pre>"},{"location":"server/graphql/types/","title":"GraphQL Types","text":"<p>The code must be placed in a file named <code>types.py</code> or within a folder named <code>types</code> located in the Application directory.</p>"},{"location":"server/graphql/types/#type-tools-reference","title":"Type Tools \u2014 Reference","text":"<ul> <li><code>zmag.Type</code> \u2014 Base class for defining types.</li> <li><code>zmag.Model</code> \u2014 Base class for defining types that include <code>_id</code> and <code>id</code>.</li> <li><code>zmag.BaseType</code> \u2014 Base class for abstract types.</li> </ul> <p>Tip</p> <p>Tools used for creating GraphQL <code>OBJECT</code> types.</p>"},{"location":"server/graphql/types/#using-zmagtype","title":"Using <code>zmag.Type</code>","text":"types.py<pre><code>from dataclasses import dataclass\nfrom typing import Annotated, TypeAlias, TypeVar\n\nimport zmag\n\n# ForwardRef\nT = TypeVar(\"T\")\nRef: TypeAlias = Annotated[T, zmag.lazy_type(\".types\")]\n\n# Create your &lt;types&gt; here.\n@dataclass\nclass Book(zmag.Type):\n    title: str | None = None\n    author: Ref[\"Author\"] | None = None\n\n\n@dataclass\nclass Author(zmag.Type):\n    name: str | None = None\n    books: list[Book] | None = None\n</code></pre>"},{"location":"server/graphql/types/#examples","title":"Examples","text":""},{"location":"server/graphql/types/#type-example","title":"Type Example","text":"<p>Creating the <code>Author</code> class using <code>zmag.Type</code>.</p> <pre><code>@dataclass\nclass Author(zmag.Type): ...\n</code></pre>"},{"location":"server/graphql/types/#model-example","title":"Model Example","text":"<p>Creating the <code>Author</code> class using <code>zmag.Model</code>.</p> <pre><code>@dataclass\nclass Author(zmag.Model): ...\n</code></pre>"},{"location":"server/graphql/types/#property-example","title":"Property Example","text":"<p>Creating a computed field <code>full_name</code> in the <code>Author</code> class with a property method.</p> <pre><code>from dataclasses import dataclass\n\nimport zmag\n\n@dataclass\nclass Author(zmag.Type):\n    first_name: str\n    last_name: str\n\n    @property\n    async def full_name(self):\n        \"\"\"Full Name\"\"\"\n        return f\"{self.first_name or ''} {self.last_name or ''}\"\n</code></pre>"}]}